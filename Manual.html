<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Calculator (Manual)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: auto; background-color: #000; color: #fff; font-size: 18px; }
    label, input, select { display: block; margin: 10px 0; }
    input { width: 100%; padding: 8px; font-size: 18px; background-color: #222; color: #fff; border: 1px solid #555; }
    select { width: 100%; padding: 8px; font-size: 18px; background-color: #222; color: #fff; border: 1px solid #555; }
    table { width: 100%; margin-top: 20px; border-collapse: collapse; text-align: center; }
    th, td { border: 1px solid #444; padding: 10px; }
    th { font-weight: bold; }
    .small { font-size: 14px; }
    .usdt { color: orange; }
    .btc { color: orange; }
    details { margin-top: 10px; margin-bottom: 20px; background-color: #111; padding: 10px; border: 1px solid #333; border-radius: 6px; }
    summary { cursor: pointer; font-weight: bold; font-size: 18px; }
    .warn { color: gold; white-space: nowrap; }
    button { background-color: #333; color: #fff; border: 1px solid #555; padding: 8px 12px; font-size: 16px; cursor: pointer; border-radius: 6px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .inline-field { display: flex; gap: 8px; align-items: center; }
    .inline-field input { flex: 1; }
  </style>
</head>
<body>

  <!-- Trade type FIRST -->
  <label>Trade type
    <select id="tradeType" onchange="calculate()">
      <option value="Long" selected>Long</option>
      <option value="Short">Short</option>
    </select>
  </label>

  <label>Risk ($): <input type="text" id="riskAmount" oninput="handleNumericInput(this, calculate)" /></label>
  <label>SL max price (= Box edge): <input type="text" id="stop" oninput="handleNumericInput(this, calculate)" /></label>

  <details>
    <summary>QUICK SETUP</summary>
    <table>
      <tr>
        <th>24m potential div price (no dot yet)</th>
        <th>Box edge price</th>
        <th>Median price</th>
      </tr>
      <tr>
        <td><input type="text" id="divPrice" oninput="handleNumericInput(this, updateQuickSetup)" /></td>
        <td><input type="text" id="boxPrice" oninput="handleNumericInput(this, updateQuickSetup)" /></td>
        <td id="medianCell"></td>
      </tr>
    </table>

    <table>
      <tr>
        <th>1/4 PS (<span class="usdt">USDT</span>)</th>
        <th>2nd Price</th>
        <th>3rd Price</th>
        <th>Orders Hit</th>
      </tr>
      <tr>
        <td id="quarterPS"></td>
        <td id="secondPrice"></td>
        <td id="thirdPrice"></td>
        <td>
          <select id="ordersHit" onchange="calculate()">
            <option value="1">1/4</option>
            <option value="2">2/4</option>
            <option value="3">3/4</option>
            <option value="4" selected>4/4</option>
          </select>
        </td>
      </tr>
    </table>
  </details>

  <label>Entry Price ($): <input type="text" id="entry" oninput="handleNumericInput(this, calculate)" /></label>

  <details>
    <summary>TP PS (%)</summary>
    <label>TP1 PS (%): <input type="number" id="tp1ps" value="30" /></label>
    <label>TP2 PS (%): <input type="number" id="tp2ps" value="30" /></label>
    <label>TPx PS (%): <input type="number" id="tpxps" value="10" /></label>
  </details>

  <!-- Moved ABOVE the Calculate button -->
  <div id="expected-sl-table">
    <table>
      <tr>
        <th>Expected TP1 price</th>
        <th>Expected TP2 price</th>
        <th>Safest SL price</th>
      </tr>
      <tr>
        <td><input type="text" id="expTP1" oninput="handleNumericInput(this, calculate)" placeholder="e.g. 100.000" /></td>
        <td><input type="text" id="expTP2" oninput="handleNumericInput(this, calculate)" placeholder="e.g. 120.000" /></td>
        <td>
          <div style="display:flex; gap:8px; align-items:center;">
            <input type="text" id="safestSL" readonly />
            <button type="button" id="updateSLBtn" onclick="updateSLFromSafest()" disabled>Update SL</button>
          </div>
          <span id="safestSLWarn" class="small warn"></span>
        </td>
      </tr>
    </table>
  </div>

  <button onclick="calculate()">Calculate</button>

  <div id="output-table"></div>
  <div id="tp-table"></div>

  <!-- TP PS in USDT -->
  <div id="tp-usdt-table">
    <table>
      <tr>
        <th>🥯TP PS <span class="btc">(BTC)</span></th>
        <th>💵TP price <span class="usdt">(USDT)</span></th>
        <th>📈TP PS <span class="usdt">(USDT)</span></th>
      </tr>
      <tr>
        <td>
          <select id="tpSelector" onchange="calculate()">
            <option value="TP1">TP1</option>
            <option value="TP2">TP2</option>
            <option value="TPx">TPx</option>
          </select>
        </td>
        <td><input type="text" id="manualTPPrice" oninput="handleNumericInput(this, calculate)" /></td>
        <td>
          <div class="inline-field">
            <input type="text" id="tpUsdtOutput" readonly onclick="this.select()" />
            <button type="button" id="copyTpUsdtBtn" onclick="copyTPUSDT()" title="Copy TP PS (USDT)" disabled>Copy</button>
          </div>
          <span id="copyStatus" class="small"></span>
        </td>
      </tr>
    </table>
  </div>

<script>
  function cleanNumber(input) {
    const raw = String(input ?? '').trim();
    if (!raw) return NaN;

    let sanitized = raw.replace(/[^\d,.-]/g, '');
    if (!sanitized) return NaN;

    const isNegative = sanitized.startsWith('-');
    sanitized = sanitized.replace(/(?!^)-/g, '');
    let unsigned = isNegative ? sanitized.slice(1) : sanitized;
    if (!unsigned) return NaN;

    let integerPart = unsigned;
    let decimalPart = '';

    if (unsigned.includes(',')) {
      const firstComma = unsigned.indexOf(',');
      integerPart = unsigned.slice(0, firstComma);
      decimalPart = unsigned.slice(firstComma + 1);
    } else if (unsigned.includes('.')) {
      const dotParts = unsigned.split('.');
      const dotCount = dotParts.length - 1;
      const lastPart = dotParts[dotParts.length - 1];

      if (dotCount === 1 && lastPart.length > 0 && lastPart.length <= 2) {
        integerPart = dotParts[0];
        decimalPart = lastPart;
      } else {
        integerPart = unsigned;
      }
    }

    integerPart = integerPart.replace(/[.,]/g, '');
    decimalPart = decimalPart.replace(/[.,]/g, '');

    if (!integerPart) integerPart = '0';

    let normalized = integerPart.replace(/^0+(?=\d)/, '');
    if (!normalized) normalized = '0';

    if (decimalPart) {
      normalized += `.${decimalPart}`;
    }

    const parsed = Number(normalized);
    if (!Number.isFinite(parsed)) return NaN;
    return isNegative ? -parsed : parsed;
  }

  function formatWithSeparators(num, options = {}) {
    if (num === null || num === undefined) return "";
    const value = Number(num);
    if (!Number.isFinite(value)) return "";
    const defaultOptions = { minimumFractionDigits: 0, maximumFractionDigits: 8 };
    const formatter = new Intl.NumberFormat('de-DE', { ...defaultOptions, ...options });
    return formatter.format(value);
  }

  function handleNumericInput(el, callback) {
    if (!el) return;

    const { selectionStart, selectionEnd } = el;
    const original = el.value;
    let sanitized = original.replace(/[^\d,.-]/g, '');
    sanitized = sanitized.replace(/(?!^)-/g, '');

    if (sanitized !== original) {
      const delta = original.length - sanitized.length;
      el.value = sanitized;
      if (selectionStart !== null && selectionStart !== undefined && selectionEnd !== null && selectionEnd !== undefined) {
        const newPos = Math.max(0, selectionStart - delta);
        requestAnimationFrame(() => el.setSelectionRange(newPos, newPos));
      }
    }

    // Keep the user's raw input without auto-formatting so decimals can be edited freely.

    if (typeof callback === 'function') {
      callback();
    }
  }

  // Compute arithmetic mean of any count of valid numbers
  function meanOf(...nums) {
    const vals = nums.filter(v => typeof v === 'number' && !isNaN(v));
    if (!vals.length) return NaN;
    return vals.reduce((a,b)=>a+b,0) / vals.length;
  }

  // Compute statistical median (middle) of valid numbers
  function medianOf(...nums) {
    const vals = nums.filter(v => typeof v === 'number' && !isNaN(v)).sort((a,b)=>a-b);
    if (!vals.length) return NaN;
    const mid = Math.floor(vals.length/2);
    if (vals.length % 2 === 1) return vals[mid];
    return (vals[mid-1] + vals[mid]) / 2;
  }

  // Handles quick-setup changes (div & box) and keeps the shown "Median price" in sync
  function updateQuickSetup() {
    const divPrice = cleanNumber(document.getElementById("divPrice").value);
    const boxPrice = cleanNumber(document.getElementById("boxPrice").value);
    if (!isNaN(divPrice) && !isNaN(boxPrice)) {
      const mid = meanOf(divPrice, boxPrice); // median between two = mean
      document.getElementById("medianCell").innerText = formatWithSeparators(mid);
    } else {
      document.getElementById("medianCell").innerText = "";
    }
    calculate(); // calculate() will now set Entry based on Orders Hit
  }

  // Copy Safest SL into SL max price and recalc
  function updateSLFromSafest() {
    const safest = document.getElementById("safestSL").value;
    if (!safest) return;
    const stopEl = document.getElementById("stop");
    stopEl.value = safest;
    handleNumericInput(stopEl, calculate);
  }

  // ===== NEW: Copy TP PS (USDT) button =====
  async function copyTPUSDT() {
    const outEl = document.getElementById('tpUsdtOutput');
    const btn = document.getElementById('copyTpUsdtBtn');
    const status = document.getElementById('copyStatus');
    if (!outEl || !outEl.value) return;

    const numeric = cleanNumber(outEl.value);
    if (isNaN(numeric)) return;

    const textToCopy = numeric.toLocaleString('en-US', {
      useGrouping: false,
      maximumFractionDigits: 8
    });
    try {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(textToCopy);
      } else {
        // Fallback for non-secure contexts
        outEl.select();
        document.execCommand('copy');
      }
      const original = btn.textContent;
      btn.textContent = 'Copied!';
      status.textContent = '';
      setTimeout(()=>{ btn.textContent = original; }, 1200);
    } catch (e) {
      status.textContent = 'Could not copy. Select and copy manually.';
    }
  }

  function syncCopyBtnState() {
    const btn = document.getElementById('copyTpUsdtBtn');
    const val = document.getElementById('tpUsdtOutput').value;
    btn.disabled = !val;
  }

  function calculate() {
    const riskAmount = cleanNumber(document.getElementById("riskAmount").value);
    const stop = cleanNumber(document.getElementById("stop").value);
    const tp1ps = parseFloat(document.getElementById("tp1ps").value);
    const tp2ps = parseFloat(document.getElementById("tp2ps").value);
    const tpxps = parseFloat(document.getElementById("tpxps").value);
    const ordersHit = parseInt(document.getElementById("ordersHit").value);
    const tradeType = document.getElementById("tradeType").value; // Long | Short
    const isLong = (tradeType === "Long");

    // Quick-setup prices
    const divPrice = cleanNumber(document.getElementById("divPrice").value);
    const boxPrice = cleanNumber(document.getElementById("boxPrice").value);

    // Derive 2nd & 3rd prices when div & box are provided
    let secondPrice = NaN, thirdPrice = NaN, quarterPS = '';
    let fullPositionSize = NaN;

    // Temporarily read entry; we'll overwrite from Orders Hit rules below
    let entry = cleanNumber(document.getElementById("entry").value);

    if (!isNaN(divPrice) && !isNaN(boxPrice)) {
      secondPrice = ((divPrice - boxPrice) / 3) + boxPrice;
      thirdPrice  = (((divPrice - boxPrice) / 3) * 2) + boxPrice;
    }

    // === Orders Hit -> Entry Price logic ===
    // 4: median price (between div and box) => mean
    // 3: median of {div, third, second} => statistical middle
    // 2: median (between div and third) => mean
    // 1: equal to div
    let computedEntry = NaN;
    if (ordersHit === 4) {
      computedEntry = meanOf(divPrice, boxPrice);
    } else if (ordersHit === 3) {
      computedEntry = medianOf(divPrice, thirdPrice, secondPrice);
    } else if (ordersHit === 2) {
      computedEntry = meanOf(divPrice, thirdPrice);
    } else if (ordersHit === 1) {
      computedEntry = divPrice;
    }

    if (!isNaN(computedEntry)) {
      entry = computedEntry;
      const entryEl = document.getElementById("entry");
      entryEl.value = formatWithSeparators(entry);
    }

    // If we still don't have core inputs, keep UI states tidy and exit
    if (isNaN(riskAmount) || isNaN(entry) || isNaN(stop)) {
      const btn = document.getElementById("updateSLBtn");
      if (btn) btn.disabled = !document.getElementById("safestSL").value;
      // Still update the quick-setup table cells
      document.getElementById("secondPrice").innerText = isNaN(secondPrice) ? "" : formatWithSeparators(secondPrice);
      document.getElementById("thirdPrice").innerText  = isNaN(thirdPrice)  ? "" : formatWithSeparators(thirdPrice);
      document.getElementById("quarterPS").innerText   = '';
      document.getElementById("output-table").innerHTML = '';
      document.getElementById("tp-table").innerHTML = '';
      // keep copy button state in sync
      syncCopyBtnState();
      return;
    }

    const stopLoss = Math.abs(entry - stop);
    const stopLossPercent = stopLoss / entry;
    fullPositionSize = riskAmount / stopLoss;
    const positionSizeBTC = fullPositionSize * (ordersHit / 4);
    const requiredCapital = positionSizeBTC * entry;
    const maxLeverage = entry / stopLoss;

    // Update quick-setup derived cells
    if (!isNaN(divPrice) && !isNaN(boxPrice)) {
      quarterPS = (fullPositionSize * entry / 4);
    }
    document.getElementById("secondPrice").innerText = isNaN(secondPrice) ? "" : formatWithSeparators(secondPrice);
    document.getElementById("thirdPrice").innerText  = isNaN(thirdPrice)  ? "" : formatWithSeparators(thirdPrice);
    document.getElementById("quarterPS").innerText   = quarterPS ? formatWithSeparators(quarterPS) : '';

    // TP min prices & max chase (directional)
    let tp1, tp2, maxChase;
    if (isLong) {
      tp1 = entry + (stopLossPercent * entry);
      tp2 = entry + (stopLossPercent * 3 * entry);
      maxChase = entry + (stopLossPercent * entry) / 2;
    } else {
      tp1 = entry - (stopLossPercent * entry);
      tp2 = entry - (stopLossPercent * 3 * entry);
      maxChase = entry - (stopLossPercent * entry) / 2;
    }

    const tp1psBTC = (fullPositionSize * (ordersHit / 4)) * (tp1ps / 100);
    const tp2psBTC = (fullPositionSize * (ordersHit / 4)) * (tp2ps / 100);
    const tpxpsBTC = (fullPositionSize * (ordersHit / 4)) * (tpxps / 100);

    document.getElementById("output-table").innerHTML = `
      <table>
        <tr>
          <th>📈Max Lev</th>
          <th>💵PS <span class="usdt">(USDT)</span></th>
          <th>⚠️Max Chase Price</th>
        </tr>
        <tr>
          <td class="small">${formatWithSeparators(maxLeverage, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}x</td>
          <td class="small">${formatWithSeparators(requiredCapital)}</td>
          <td class="small">${formatWithSeparators(maxChase)}</td>
        </tr>
      </table>`;

    document.getElementById("tp-table").innerHTML = `
      <table>
        <tr>
          <th></th>
          <th>🟢TP1</th>
          <th>🟡TP2</th>
          <th>🟠TPx</th>
        </tr>
        <tr>
          <th>💵Min Price <span class="usdt">(USDT)</span></th>
          <td class="small">${formatWithSeparators(tp1)}</td>
          <td class="small">${formatWithSeparators(tp2)}</td>
          <td class="small"></td>
        </tr>
        <tr>
          <th>🥯PS <span class="btc">(BTC)</span></th>
          <td class="small">${formatWithSeparators(tp1psBTC, { maximumFractionDigits: 6 })}</td>
          <td class="small">${formatWithSeparators(tp2psBTC, { maximumFractionDigits: 6 })}</td>
          <td class="small">${formatWithSeparators(tpxpsBTC, { maximumFractionDigits: 6 })}</td>
        </tr>
      </table>`;

    // ===== Safest SL calculator (Long: max; Short: min) =====
    {
      const expTP1 = cleanNumber(document.getElementById("expTP1").value);
      const expTP2 = cleanNumber(document.getElementById("expTP2").value);
      const warnSpan = document.getElementById("safestSLWarn");
      const safestSLInput = document.getElementById("safestSL");

      const have1 = !isNaN(expTP1) && expTP1 > 0;
      const have2 = !isNaN(expTP2) && expTP2 > 0;

      let minSL1 = null, minSL2 = null;

      if (have1) {
        const d1 = Math.abs(expTP1 - entry); // 1R to TP1
        minSL1 = isLong ? (entry - d1) : (entry + d1);
      }
      if (have2) {
        const d2 = Math.abs(expTP2 - entry) / 3; // 3R to TP2
        minSL2 = isLong ? (entry - d2) : (entry + d2);
      }

      let safestSL = null;
      const candidates = [minSL1, minSL2].filter(v => v !== null && !isNaN(v));
      if (candidates.length) {
        // Requested: Long -> biggest; Short -> smallest
        safestSL = isLong ? Math.max(...candidates) : Math.min(...candidates);
      }

      if (safestSL !== null && !isNaN(safestSL)) {
        safestSLInput.value = formatWithSeparators(safestSL);
        // Directional warning: Long → warn if safestSL > stop; Short → warn if safestSL < stop
        if (!isNaN(stop) && ((isLong && safestSL > stop) || (!isLong && safestSL < stop))) {
          warnSpan.textContent = "⚠️Safest SL worse than SL (max), don't take the trade";
        } else {
          warnSpan.textContent = "";
        }
      } else {
        safestSLInput.value = "";
        warnSpan.textContent = "";
      }

      const updateBtn = document.getElementById("updateSLBtn");
      if (updateBtn) updateBtn.disabled = !safestSLInput.value;
    }

    // ===== TP USDT quick calc =====
    const selected = document.getElementById("tpSelector").value;
    const inputPrice = cleanNumber(document.getElementById("manualTPPrice").value);
    const selectedPSBTC = selected === "TP1" ? tp1psBTC : selected === "TP2" ? tp2psBTC : tpxpsBTC;

    let tpUsdt = null;
    if (!isNaN(inputPrice) && inputPrice > 0) {
      if (isLong) {
        tpUsdt = (selectedPSBTC * (inputPrice - entry)) + (entry * selectedPSBTC);
      } else {
        tpUsdt = (selectedPSBTC * (entry - inputPrice)) + (entry * selectedPSBTC);
      }
    }
    const tpUsdtOutput = (!isNaN(tpUsdt) && tpUsdt !== null) ? formatWithSeparators(tpUsdt) : '';
    document.getElementById("tpUsdtOutput").value = tpUsdtOutput;

    // Keep copy button in sync
    syncCopyBtnState();
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', () => {
    syncCopyBtnState();
  });
</script>
</body>
</html>